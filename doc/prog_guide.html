<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>libmsvg programmer's guide</title>
</head>

<body>
<h1>libmsvg v0.12</h1>
<h2>Programmer's guide</h2>
<p>Last update: April 28, 2020</p>

<hr>
<h2>Abstract</h2>
<p><b>libmsvg</b> is a minimal and generic C library to read and write SVG
files.</p>

<p>SVG stand for Scalable Vector Graphics and is a standard defined by the
World Wide Web Consortium (see <a href="http://www.w3.org/Graphics/SVG/">
http://www.w3.org/Graphics/SVG/</a>).</p>

<p><b>libmsvg</b> concentrates on a small subset of SVG to be useful. More
specifically on a subset of the <a href="http://www.w3.org/TR/SVGTiny12/">
SVG Tiny 1.2 specification</a>. The subset is described in <a href="#appendixa">
Appendix A</a>.</p>

<h2>Contents</h2>
<dir>
<li><a href="#start">Starting with examples</a>
<li><a href="#svgtree">The MsvgElement tree</a>
<li><a href="#element">The MsvgElement structure</a>
<li><a href="#reading">Reading SVG files</a>
<li><a href="#buildraw">Building a RAW MsvgElement tree by program</a>
<li><a href="#buildcooked">Building a COOKED MsvgElement tree by program</a>
<li><a href="#manipulating">Manipulating a MsvgElement tree</a>
<li><a href="#serialize">Serialize a COOKED MsvgElement tree</a>
<li><a href="#writing">Writing SVG files</a>
<li><a href="#appendixa">Appendix A, the libmsvg SVG subset</a>
<li><a href="#appendixb">Appendix B, parameters values</a>

</dir>

<hr>
<h2><a name="start">Starting with examples</a></h2>
<p>I think the best way to start with a programmer's guide is to show examples,
so here there are.</p>

<h3>Example 1</h3>
<p>This example read a SVG file in a  MsvgElement tree</p>
<pre>
#include &lt;stdio.h>
#include "msvg.h"

int main(int argc, char **argv)
{
  MsvgElement *root;

  if (argc &lt;2)
    return 0;

  root = MsvgReadSvgFile(argv[1]);

  if (root == NULL) {
    printf("Error opening %s\n", argv[1]);
    return 0;
  }

  /* Now you can process the structure. By example: */
  MsvgPrintRawElementTree(stdout, root, 0);

  return 1;
}
</pre>

<h3>Example 2</h3>
<p>This example builds a MsvgElement tree and writes it to a file</p>
<pre>
#include <stdio.h>
#include "msvg.h"

#define TESTFILE "msvgt2.svg"

int main(int argc, char **argv)
{
  MsvgElement *root, *son;

  root = MsvgNewElement(EID_SVG, NULL);
  MsvgAddRawAttribute(root, "xmlns", "http://www.w3.org/2000/svg");
  MsvgAddRawAttribute(root, "version", "1.2");
  MsvgAddRawAttribute(root, "baseProfile", "tiny");
  MsvgAddRawAttribute(root, "viewBox", "0 0 400 400");

  son = MsvgNewElement(EID_RECT, root);
  MsvgAddRawAttribute(son, "x", "1");
  MsvgAddRawAttribute(son, "y", "1");
  MsvgAddRawAttribute(son, "width", "398");
  MsvgAddRawAttribute(son, "height", "398");
  MsvgAddRawAttribute(son, "stroke", "#F00");
  MsvgAddRawAttribute(son, "fill", "#FFF");

  son = MsvgNewElement(EID_RECT, root);
  MsvgAddRawAttribute(son, "x", "11");
  MsvgAddRawAttribute(son, "y", "11");
  MsvgAddRawAttribute(son, "width", "380");
  MsvgAddRawAttribute(son, "height", "380");
  MsvgAddRawAttribute(son, "stroke", "#0F0");
  MsvgAddRawAttribute(son, "fill", "none");
  MsvgPrintRawElementTree(stdout, root, 0);

  if (!MsvgWriteSvgFile(root, TESTFILE)) {
    printf("Error writing %s\n", TESTFILE);
    return 0;
  }

  return 1;

</pre>

<h3>How to compile the example programs</h3>
<p>We assume here that you have the libmsvg library previously installed. If not,
please read the "readme" file for installation instructions.</p>
<p>These are the command lines to compile the examples for the three supported
platforms:</p>
<ul>
	<li>Linux: gcc -o example example.c -lmsvg
	<li>DJGPP: gcc -o example.exe example.c -lmsvg
	<li>Mingw: gcc -o example.exe example.c -lmsvg -mconsole
</ul>

<hr>
<h2><a name="svgtree">The MsvgElement tree</a></h2>
<p>The central structure of libmsvg is the MsvgElement tree. Every MsvgElement
has a element type id (eid), a pointer to his father, pointers to his previous
and next siblings and a pointer to his first son. The root element must be a
EID_SVG. In this version of libmsvg only EID_SVG and EID_G can have son elements.
The other supported elements are EID_RECT, EID_CIRCLE, EID_ELLIPSE, EID_LINE,
EID_POLYLINE and EID_POLYGON.</p>
<p>This graph represents an example of a MsvgElement tree:</p>
<p><center>
<img src="elementtree.png" alt="MsvgElement tree example">
</center></p>
<p>Every MsvgElement can have attributes, they can be of two types: raw or
cooked. The type of MsvgElement attributes in a tree is determined by a variable in
the root element: root->psvgattr->tree_type. If this variable is RAW_SVGTREE all
attributes are raw. Raw attributes are simple key,value strings pairs. If it is a
COOKED_SVGTREE all attributes are cooked. Cooked attributes are typed variables
and can be generic or specific, all elements have the generic ones, each 
element type id can have his specific ones. </p>

<h3>The RAW_SVGTREE tree type</h3>
<p>After a SVG file is loaded to a MsvgElement tree by the MsvgReadSvgFile function
it is marked as a RAW_SVGTREE. Only the supported elements are inserted in the tree,
but all the read attributes are stored like raw attributes. This stage of the
tree can suffice for some programs. Elements and attributes can be added, deleted or
reordered and finally be written to a file using the MsvgWriteSvgFile function.</p>

<h3>The COOKED_SVGTREE tree type</h3>
<p>Using the MsvgRaw2CookedTree funtion you
can convert a MsvgElement tree to the COOKED_SVGTREE type. Only the supported
attributes are processed and converted to cooked attributes. In this state the tree
is easier to manipulate and rasterize by a program.</p>

<hr>
<h2><a name="element">The MsvgElement structure</a></h2>
<p>After reading the previous section it must be easy to undestand the MsvgElement
structure from the msvg.h include file:</p>
<pre>
typedef struct _MsvgElement *MsvgElementPtr;

typedef struct _MsvgElement {
    enum EID eid;               /* element type id */
    MsvgElementPtr father;      /* pointer to father element */
    MsvgElementPtr psibling;    /* pointer to previous sibling element */
    MsvgElementPtr nsibling;    /* pointer to next sibling element */
    MsvgElementPtr fson;        /* pointer to first son element */

    MsvgRawAttributePtr frattr; /* pointer to first raw attribute */

    /* cooked generic attributes */
    char *id;                   /* id attribute */
    MsvgPaintCtx pctx;          /* painting context */

    /* cooked specific attributes */
    union {
        MsvgSvgAttributes *psvgattr;
        MsvgGAttributes *pgattr;
        MsvgRectAttributes *prectattr;
        MsvgCircleAttributes *pcircleattr;
        MsvgEllipseAttributes *pellipseattr;
        MsvgLineAttributes *plineattr;
        MsvgPolylineAttributes *ppolylineattr;
        MsvgPolygonAttributes *ppolygonattr;
    };
} MsvgElement;
</pre>

<p>Raw attributes are stored in a simple linked list of MsvgRawAttribute
variables:</p>
<pre>
typedef struct _MsvgRawAttribute *MsvgRawAttributePtr;

typedef struct _MsvgRawAttribute {
    char *key;                  /* key attribute */
    char *value;                /* value attribute */
    MsvgRawAttributePtr nrattr; /* pointer to next raw attribute */
} MsvgRawAttribute;
</pre>

<p>Cooked generic attributes are the same for all elements, the "id" attribute
(that can be NULL) and a MsvgPaintCtx structure:</p>
<pre>
typedef struct _MsvgPaintCtx {
    rgbcolor fill;         /* fill color attribute */
    double fill_opacity;   /* fill-opacity attribute */
    rgbcolor stroke;       /* stroke color attribute */
    double stroke_width;   /* stroke-width attribute */
    double stroke_opacity; /* stroke-opacity attribute */
} MsvgPaintCtx;
</pre>

<p>it is important to note that all attributes in the MsvgPaintCtx can
be inherited from his father element. This can be do explicitly with the value
INHERIT_COLOR (for colors) or INHERIT_VALUE (for doubles), that correspond
to the raw keyword value "inherit", or implicitly when
the value is NODEFINED_COLOR (for colors) or NODEFINED_VALUE, that occurs when
the raw value is not defined, and the father value is defined.</p>

<p>fill and stroke colors can have the value NO_COLOR, that correspond
to the raw keyword value "none" that means fill or stroke must not be done.</p>

<p>Cooked specific attributes are different for each element type id and stored
in a union, you can inspect each one in the msvg.h include file.</p>

<hr>
<h2><a name="reading">Reading SVG files</a></h2>
<p>Using the MsvgReadSvgFile function you load a SVG file in a MsvgElement
tree.</p>

<pre>
  MsvgElement *root;
  root = MsvgReadSvgFile("filein.svg");
</pre>

<p>If the file doesn't exists or it isn't a valid SVG file root will be NULL,
so you must check it. Only the supported elements are stored in the tree, the
not supported ones are silently ignored. The tree will be a RAW tree, with all
the element attributes stored as raw attributes. If you want a COOKED tree
you can use the MsvgRaw2CookedTree funtion:</p>

<pre>
  int result;
  result = MsvgRaw2CookedTree(root);
</pre>

<p>result will be true if all was right, false otherwise. Note that after calling
this function you have really a mixed RAW/COOKED tree, because all raw parameters
are preserved. If you are sure you don't need the raw parameters anymore you can
call the MsvgDelAllTreeRawAttributes function:</p>

<pre>
  int result;
  result = MsvgDelAllTreeRawAttributes(root);
</pre>

<p>result will be the number of raw parameters deleted.</p>

<hr>
<h2><a name="buildraw">Building a RAW MsvgElement tree by program</a></h2>
<p>Using only two function we can construct a MsvgElement tree by program. The
MsvgNewElement function takes two parameters: the element type id and the father
element, that can be NULL. It returns the pointer to the constructed
element.</p>
<p>So we begin constructing the SVG element passing NULL in the father
parameter, because it is the root element. By default the tree will be
RAW_SVGTREE.</p> 

<pre>
  MsvgElement *root;
  root = MsvgNewElement(EID_SVG, NULL);
</pre>

<p>Now, we add attributes to identify the svg element properly and set the
drawing limits using the MsvgAddRawAttribute function.</p>

<pre>
  MsvgAddRawAttribute(root, "xmlns", "http://www.w3.org/2000/svg");
  MsvgAddRawAttribute(root, "version", "1.2");
  MsvgAddRawAttribute(root, "baseProfile", "tiny");
  MsvgAddRawAttribute(root, "viewBox", "0 0 400 400");
</pre>

<p>We continue adding two son elements, a RECT element and a G element.</p>

<pre>
  MsvgElement *son;
  son = MsvgNewElement(EID_RECT, root);
  MsvgAddRawAttribute(son, "x", "1");
  MsvgAddRawAttribute(son, "y", "1");
  MsvgAddRawAttribute(son, "width", "398");
  MsvgAddRawAttribute(son, "height", "398");
  MsvgAddRawAttribute(son, "stroke", "#F00");
  MsvgAddRawAttribute(son, "fill", "#FFF");
  son = MsvgNewElement(EID_G, root);
  MsvgAddRawAttribute(son, "stroke", "#0F0");
  MsvgAddRawAttribute(son, "fill", "none");
</pre>

<p>Finally we add two son CIRCLE elements to the G element. Note that they
will inherit the stroke and fill attributes.</p>

<pre>
  MsvgElement *soon2;
  son2 = MsvgNewElement(EID_CIRCLE, son);
  MsvgAddRawAttribute(son2, "cx", "100");
  MsvgAddRawAttribute(son2, "cy", "200");
  MsvgAddRawAttribute(son2, "r", "80");
  son2 = MsvgNewElement(EID_CIRCLE, son);
  MsvgAddRawAttribute(son2, "cx", "300");
  MsvgAddRawAttribute(son2, "cy", "200");
  MsvgAddRawAttribute(son2, "r", "80");
</pre>

<p>We have now our MsvgElement tree and we can manipulate it or write it to
a file.</p>

<hr>
<h2><a name="buildcooked">Building a COOKED MsvgElement tree by program</a></h2>
<p>Here you have two options, you can construct a RAW MsvgElement tree and them
call MsvgRaw2CookedTree or you can construct a COOKED tree directly.</p>

<p>Constructing a COOKED tree is the same like constructing a RAW one, except we
don't use the MsvgAddRawAttribute function. Instead we set directly the element
cooked attributes, there are no functions to hide the variables, because we are
programmers and we know what are we doing, doesn't it.</p>

<pre>
  MsvgElement *root;
  root = MsvgNewElement(EID_SVG, NULL);
  root->psvgattr->vb_min_x = 0;
  root->psvgattr->vb_min_y = 0;
  root->psvgattr->vb_width = 400;
  root->psvgattr->vb_height = 400;
  root->psvgattr->tree_type = COOKED_SVGTREE;

  MsvgElement *son;
  son = MsvgNewElement(EID_RECT, root);
  son->prectattr->x = 1;
  son->prectattr->y = 1;
  son->prectattr->width = 398;
  son->prectattr->height = 398;
  son->pctx.fill = 0XFFFFFF;
  son->pctx.stroke = 0XFF0000;
  son = MsvgNewElement(EID_G, root);
  son->pctx.fill = NO_COLOR;
  son->pctx.stroke = 0X00FF00;

  MsvgElement *soon2;
  son2 = MsvgNewElement(EID_CIRCLE, son);
  son2->pcircleattr->cx = 100;
  son2->pcircleattr->cy = 200;
  son2->pcircleattr->r = 80;
  son2 = MsvgNewElement(EID_CIRCLE, son);
  son2->pcircleattr->cx = 300;
  son2->pcircleattr->cy = 200;
  son2->pcircleattr->r = 80;
</pre>

<hr>
<h2><a name="manipulating">Manipulating a MsvgElement tree</a></h2>
<p>There are some functions to manipulate a MsvgElement tree.</p>

<pre>
void MsvgPruneElement(MsvgElement *el);
</pre>
<p>The MsvgPruneElement function prune an element from his tree and them we
can insert it in another tree or in another point of the same tree. Note that
if the pruned element has sons, it retains them after pruned.</p>

<pre>
void MsvgDeleteElement(MsvgElement *el);
</pre>
<p>The MsvgDeleteElement does two things, prunes the element from his tree and
deletes it, freeing the allocated memory used. Note that if the deleted
element has sons, they are deleted too.</p>

<pre>
int MsvgInsertSonElement(MsvgElement *el, MsvgElement *father);
int MsvgInsertPSiblingElement(MsvgElement *el, MsvgElement *sibling);
int MsvgInsertNSiblingElement(MsvgElement *el, MsvgElement *sibling);
</pre>
<p>This three functios insert an element (that can be a subtree if it has sons) in
the desired point of a tree. The MsvgInsertSonElement fucntion inserts the element
like the last son of the indicated father. The MsvgInsertPSiblingElement function
inserts the element like a previous sibling to the indicated sibling. And the
MsvgInsertNSiblingElement function inserts the element like a next sibling. The
three functions return 1 if all was ok, 0 otherwise.</p>

<pre>
MsvgElement *MsvgDupElement(MsvgElement *el);
</pre>
<p>The MsvgDupElement duplicates the element passed as parameter, if that
element is a container (like  EID_SVG or EID_G) it duplicates all the element
sons too.</p>

<hr>
<h2><a name="serialize">Serialize a COOKED MsvgElement tree</a></h2>
<p>libmsvg provides a function to serialize a COOKED MsvgElement tree. Using
this function is the easier way to rasterize a MsvgElement tree.</p>

<pre>
int MsvgSerCookedTree(MsvgElement *root, MsvgSerUserFn sufn);
</pre>

<p>this function will process the tree and call the supply user function
for every drawable element (not for container elements). The user function
must be defined as:</p>

<pre>
typedef void (*MsvgSerUserFn)(MsvgElement *el, MsvgPaintCtx *pctx);
</pre>

<p>where "el" is the pointer to the drawable element and pctx a pointer
to a constructed MsvgPaintCtx whit all the inherit and initial values processed,
so the user program must use this painting context instead the element one
to do the drawing.</p>

<hr>
<h2><a name="writing">Writing SVG files</a></h2>
<p>Using the MsvgWriteSvgFile function you can write a MsvgElement tree to a file.</p>

<pre>
  MsvgElement *root;
  int result;
  // construct the root tree
  result = MsvgWriteSvgFile(root, "fileout.svg")
</pre>

<p>MsvgWriteSvgFile only know how to write RAW trees. If you want to write a COOKED
only tree you need to use the MsvgCooked2RawTree funtion (<font color="#aa0000">to
be added to the library</font>) first:</p>

<pre>
  int result;
  result = MsvgCooked2RawTree(root);
</pre>

<hr>
<h2><a name="appendixa">Appendix A, the libmsvg SVG subset</a></h2>
<p>This table lists the SVG elementes and attributes that will be
supported when libmsvg reaches version 0.20.</p>
<p>Each row lists an element, the supported attributes and the
possible elements that may be sons.</p>
<p>Note that attributes listed only affects to COOKED trees, RAW trees
can have any attribute.</p>
<p>A status mark is added to each attribute: (ok) means it is already supported,
(TO DO) means... you know: to do.</p>

<table width=100% border=1 cellpadding=4 cellspacing=3>
  <tr valign=top>
    <th width=25%>
      <p>Element</p>
    </th>
    <th width=44%>
      <p>Specific supported attributes (status)</p>
    </th>
    <th width=31%>
      <p>Possible son elements</p>
    </th>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;svg&gt;</p>
    </td>
    <td width=44%>
      <p>xmlns=&quot;http://www.w3.org/2000/svg&quot; (fixed value)</p>
      <p>version=&quot;1.2&quot; (fixed value)</p>
      <p>baseprofile=&quot;tiny&quot; (fixed value)</p>
      <p>viewbox=&quot;min-x min-y width height&quot; (ok)</p>
      <p>width=&quot;width&quot; (need to record units)</p>
      <p>height=&quot;height&quot; (need to record units)</p>
      <p>preserveaspectratio=&quot;valor&quot; (TO DO)</p>
      <p>viewport-fill=&quot;color&quot; (ok)</p>
      <p>viewport-fill-opacity=&quot;n&quot; (ok)</p>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>--- for possible inheritance ---</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
    </td>
    <td width=31%>
      <p>&lt;defs&gt;, &lt;g&gt;, &lt;rect&gt;, &lt;circle&gt;, &lt;ellipse&gt;,
      &lt;line&gt;, &lt;polyline&gt;, &lt;polygon&gt;</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;defs&gt; (TO DO)</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (TO DO)</p>
      <p>fill=&quot;color&quot; (TO DO)</p>
      <p>fill-opacity=&quot;n&quot; (TO DO)</p>
      <p>stroke=&quot;color&quot; (TO DO)</p>
      <p>stroke-width=&quot;n&quot; (TO DO)</p>
      <p>stroke-opacity=&quot;n&quot; (TO DO)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p>&lt;g&gt;, &lt;rect&gt;, &lt;circle&gt;, &lt;ellipse&gt;,
      &lt;line&gt;, &lt;polyline&gt;, &lt;polygon&gt;</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;g&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p>&lt;g&gt;, &lt;rect&gt;, &lt;circle&gt;, &lt;ellipse&gt;,
      &lt;line&gt;, &lt;polyline&gt;, &lt;polygon&gt;</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;use&gt; (TO DO)</p>
    </td>
    <td width=44%>
      <p>xlink:href =&quot;IRI&quot; (TO DO)</p>
      <p>x=&quot;n&quot; (TO DO)</p>
      <p>y=&quot;n&quot; (TO DO)</p>
      <p>fill=&quot;color&quot; (TO DO)</p>
      <p>fill-opacity=&quot;n&quot; (TO DO)</p>
      <p>stroke=&quot;color&quot; (TO DO)</p>
      <p>stroke-width=&quot;n&quot; (TO DO)</p>
      <p>stroke-opacity=&quot;n&quot; (TO DO)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;rect&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>x=&quot;n&quot; (ok)</p>
      <p>y=&quot;n&quot; (ok)</p>
      <p>width=&quot;n&quot; (ok)</p>
      <p>height=&quot;n&quot; (ok)</p>
      <p>rx=&quot;n&quot; (ok)</p>
      <p>ry=&quot;n&quot; (ok)</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;circle&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>cx=&quot;n&quot; (ok)</p>
      <p>cy=&quot;n&quot; (ok)</p>
      <p>r=&quot;n&quot; (ok)</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;ellipse&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>cx=&quot;n&quot; (ok)</p>
      <p>cy=&quot;n&quot; (ok)</p>
      <p>rx=&quot;n&quot; (ok)</p>
      <p>ry=&quot;n&quot; (ok)</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;line&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>x1=&quot;n&quot; (ok)</p>
      <p>y1=&quot;n&quot; (ok)</p>
      <p>x2=&quot;n&quot; (ok)</p>
      <p>y2=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;polyline&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>points=&quot;data&quot; (ok)</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
  <tr valign=top>
    <td width=25%>
      <p>&lt;polygon&gt;</p>
    </td>
    <td width=44%>
      <p>id=&quot;valor&quot; (ok)</p>
      <p>points=&quot;data&quot; (ok)</p>
      <p>fill=&quot;color&quot; (ok)</p>
      <p>fill-opacity=&quot;n&quot; (ok)</p>
      <p>stroke=&quot;color&quot; (ok)</p>
      <p>stroke-width=&quot;n&quot; (ok)</p>
      <p>stroke-opacity=&quot;n&quot; (ok)</p>
      <p>transform=&quot;transformation&quot; (TO DO)</p>
    </td>
    <td width=31%>
      <p><br>
      </p>
    </td>
  </tr>
</table>

<hr>
<h2><a name="appendixb">Appendix B, parameters values</a></h2>
<p>This table list the possible values that some parameters can have.</p>
<p>Note that these are the values that are expected when converting to a COOKED tree,
RAW parameters can have any value.</p>
<p>A status mark is added to each value: (ok) means it is already supported,
(TO DO) means... you know: to do.</p>

<table width=100% border=1 cellpadding=4 cellspacing=3>
  <tr valign=top>
    <th width=20%>
      <p>Parameters</p>
    </th>
    <th width=50%>
      <p>Raw value => Cooked value (status)</p>
    </th>
    <th width=30%>
      <p>Notes</p>
    </th>
  </tr>
  <tr valign=top>
    <td width=20%>
      <p>viewport-fill</p>
      <p>fill</p>
      <p>stroke</p>
    </td>
    <td width=40%>
      <p>NO DEFINED => NODEFINED_COLOR (ok)</p>
      <p>none => NO_COLOR (ok)</p>
      <p>currentColor => INHERIT_COLOR (ok)</p>
      <p>inherit => INHERIT_COLOR (ok)</p>
      <p>black => 0x000000 (ok)</p>
      <p>silver => 0xc0c0c0 (ok)</p>
      <p>gray => 0x808080 (ok)</p>
      <p>white => 0xffffff (ok)</p>
      <p>maroon => 0x800000 (ok)</p>
      <p>red => 0xff0000 (ok)</p>
      <p>purple => 0x800080 (ok)</p>
      <p>fuchsia => 0xff00ff (ok)</p>
      <p>green => 0x008000 (ok)</p>
      <p>lime => 0x00ff00 (ok)</p>
      <p>olive => 0x808000 (ok)</p>
      <p>yellow => 0xffff00 (ok)</p>
      <p>navy => 0x000080 (ok)</p>
      <p>blue => 0x0000ff (ok)</p>
      <p>teal => 0x008080 (ok)</p>
      <p>aqua => 0x00ffff (ok)</p>
      <p>#rgb => 0xrrggbb (ok)</p>
      <p>#rrggbb => 0xrrggbb (ok)</p>
      <p>rgb(rrr, ggg, bbb) => 0xrrggbb (TO DO)</p>
    </td>
    <td width=40%>
      <p>If viewport-fill is not defined it will be NO_COLOR</p>
      <p>If after the inheritance process fill is not defined it will be 0x000000</p>
      <p>If after the inheritance process stroke is not defined it will be NO_COLOR</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=20%>
      <p>viewport-fill-opacity</p>
      <p>fill-opacity</p>
      <p>stroke-opacity</p>
    </td>
    <td width=40%>
      <p>NO DEFINED => NODEFINED_VALUE (ok)</p>
      <p>inherit => INHERIT_VALUE (ok)</p>
      <p>number between 0.0 and 1.0 => same value (ok)</p>
    </td>
    <td width=40%>
      <p>If viewport-fill-opacity is not defined it will be 1</p>
      <p>If after the inheritance process fill-opacity is not defined it will be 1</p>
      <p>If after the inheritance process stroke-opacity is not defined it will be 1</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=20%>
      <p>stroke-width</p>
    </td>
    <td width=40%>
      <p>NO DEFINED => NODEFINED_VALUE (ok)</p>
      <p>inherit => INHERIT_VALUE (ok)</p>
      <p>number > 0.0 => same value (ok)</p>
    </td>
    <td width=40%>
      <p>If after the inheritance process stroke-width is not defined it will be 1</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=20%>
      <p>transform</p>
    </td>
    <td width=40%>
      <p>NO DEFINED => (1 0 0 1 0 0) (ok)</p>
      <p>none => (1 0 0 1 0 0) (TO DO)</p>
      <p>matrix(a b c d e f) => (a b c d e f) (TO DO)</p>
      <p>translate(x) => (1 0 0 1 x 0) (TO DO)</p>
      <p>translate(x y) => (1 0 0 1 x y) (TO DO)</p>
      <p>rotate(ang) => (cos(ang) sin(ang) -sin(ang) cos(ang) 0 0) (TO DO)</p>
      <p>rotate(ang cx cy) => traslate(cx cy) * rotate(ang) * translate(-cx -cy) (TO DO)</p>
      <p>scale(sx) => (sx 0 0 sx 0 0) (TO DO)</p>
      <p>scale(sx sy) => (sx 0 0 sy 0 0) (TO DO)</p>
      <p>ref(svg) => no transform for this element (TO DO)</p>
    </td>
    <td width=40%>
      <p>Note that before a drawable element can be rasterized it is necesary to
      calculate the current transformation matrix multiplying all transformation
      matrix from his parents elements.</p>
    </td>
  </tr>
  <tr valign=top>
    <td width=20%>
      <p>points</p>
    </td>
    <td width=40%>
      <p>x1,y1 x2,y2 ... => same values (ok)</p>
    </td>
    <td width=40%>
    </td>
  </tr>

</body>
</html>
